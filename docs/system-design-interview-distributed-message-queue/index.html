<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>System Design Interview - Distributed Message Queue | Serhat Giydiren</title>
<meta name="keywords" content="system design, distributed systems, message queue, scalability, architecture, interview prep">
<meta name="description" content="A deep dive into designing a distributed message queue system. This guide covers core concepts from producers and consumers to advanced topics like delivery semantics (at-least-once, exactly-once), data partitioning, fault tolerance, and achieving high throughput.">
<meta name="author" content="">
<link rel="canonical" href="https://serhatgiydiren.com/system-design-interview-distributed-message-queue/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://serhatgiydiren.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://serhatgiydiren.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://serhatgiydiren.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://serhatgiydiren.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://serhatgiydiren.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://serhatgiydiren.com/system-design-interview-distributed-message-queue/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://serhatgiydiren.com/system-design-interview-distributed-message-queue/">
  <meta property="og:site_name" content="Serhat Giydiren">
  <meta property="og:title" content="System Design Interview - Distributed Message Queue">
  <meta property="og:description" content="A deep dive into designing a distributed message queue system. This guide covers core concepts from producers and consumers to advanced topics like delivery semantics (at-least-once, exactly-once), data partitioning, fault tolerance, and achieving high throughput.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-03-04T09:25:27+00:00">
    <meta property="article:modified_time" content="2021-03-04T09:25:27+00:00">
    <meta property="article:tag" content="System Design">
    <meta property="article:tag" content="Distributed Systems">
    <meta property="article:tag" content="Message Queue">
    <meta property="article:tag" content="Scalability">
    <meta property="article:tag" content="Architecture">
    <meta property="article:tag" content="Interview Prep">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="System Design Interview - Distributed Message Queue">
<meta name="twitter:description" content="A deep dive into designing a distributed message queue system. This guide covers core concepts from producers and consumers to advanced topics like delivery semantics (at-least-once, exactly-once), data partitioning, fault tolerance, and achieving high throughput.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://serhatgiydiren.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "System Design Interview - Distributed Message Queue",
      "item": "https://serhatgiydiren.com/system-design-interview-distributed-message-queue/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "System Design Interview - Distributed Message Queue",
  "name": "System Design Interview - Distributed Message Queue",
  "description": "A deep dive into designing a distributed message queue system. This guide covers core concepts from producers and consumers to advanced topics like delivery semantics (at-least-once, exactly-once), data partitioning, fault tolerance, and achieving high throughput.",
  "keywords": [
    "system design", "distributed systems", "message queue", "scalability", "architecture", "interview prep"
  ],
  "articleBody": "For a curated list of system design interview resources, check out our Helpful Resources for System Design Interviews page.\nFor a comprehensive list of resources for tech interviews, check out our Best Resources for Tech Interviews page.\n1. Introduction: The Power of Asynchronous Communication In modern distributed systems, services need to communicate with each other. Synchronous communication (e.g., via REST APIs) is simple but creates tight coupling; if the receiving service is slow or down, the sending service is blocked. This brittleness is a major liability at scale.\nMessage Queues are a foundational technology for building robust, scalable, and decoupled systems. They enable asynchronous communication: a service (the producer) sends a message to a queue without waiting for the recipient (the consumer) to process it. The consumer can then process the message at its own pace.\nA single-node message queue, however, has limitations:\nLimited Throughput: A single server can only handle a finite number of messages per second. Single Point of Failure (SPOF): If the server fails, the entire communication backbone of the application goes down. Limited Storage: It can only store a limited number of messages. To overcome these, we build a Distributed Message Queue: a cluster of servers (brokers) that work together to provide a single, highly scalable and resilient messaging service. This guide explores the design of such a system in an interview context.\n2. Core Requirements and Design Goals Functional Requirements:\nPublish(topic, message): A producer sends a message to a specific topic. Subscribe(topic): A consumer subscribes to a topic to receive messages. Acknowledge(message): A consumer informs the queue that a message has been successfully processed. Non-Functional Requirements:\nHigh Throughput: The system must handle a very large number of messages per second (millions, in some cases). High Scalability: Must scale horizontally by adding more brokers to handle increased load. High Availability \u0026 Fault Tolerance: The system must remain operational and not lose messages even if some brokers fail. Durability: Once a message is accepted by the queue, it should not be lost. Tunable Delivery Semantics: The system should support different guarantees for message delivery. 3. High-Level Architecture A distributed message queue consists of a few key components:\nProducers: Client applications that create and send messages. Consumers: Client applications that subscribe to topics and process messages. Brokers: The core servers that form the queue cluster. They are responsible for receiving messages from producers, storing them, and delivering them to consumers. Topics (or Queues): Named channels to which messages are published. A topic represents a specific stream of data. 4. Core Challenge 1: Partitioning for Scalability To achieve high throughput, a single topic must be spread across multiple brokers. This is done through partitioning (or sharding).\nA topic is divided into multiple partitions. Each partition is an independent, ordered sequence of messages. Each partition is managed by a single broker, which acts as the leader for that partition. When a producer sends a message to a topic, it must decide which partition to send it to. This can be done in several ways: Round-Robin: Distribute messages evenly across all partitions. This is good for load balancing but does not guarantee message ordering. Key-Based Partitioning: partition_index = hash(key) % num_partitions. All messages with the same key (e.g., user_id) will go to the same partition. This is crucial as it guarantees message ordering for a given key. By partitioning a topic, we can process messages in parallel across many brokers and consumers, allowing the system to scale horizontally.\n5. Core Challenge 2: Durability and Storage How do brokers store messages to ensure they are not lost?\nIn-Memory Storage: Extremely fast but not durable. If a broker crashes, all messages it holds are lost. Unsuitable for most use cases. Disk-Based Storage: Messages are written to disk, providing durability. The main challenge is performance. Modern systems like Apache Kafka use a log-structured storage model. Each partition is an append-only log file on disk.\nWrites are extremely fast sequential appends. Reads are also sequential (consumers read messages in order). This model leverages the operating system’s page cache for fast access while ensuring data is safely persisted on disk. 6. Core Challenge 3: Delivery Semantics This is often the most critical part of the design discussion. What guarantee does the system provide about message delivery?\nAt-Most-Once The producer sends a message. If there’s a network error or broker failure, the message might be lost. The producer does not retry. Pros: Highest throughput, lowest latency. Cons: Messages can be lost. Suitable for non-critical data like metrics collection. At-Least-Once The producer sends a message and waits for an acknowledgment (ACK) from the broker. If no ACK is received, the producer retries. The consumer fetches a message, processes it, and then sends an ACK to the broker. If the broker doesn’t receive an ACK (e.g., the consumer crashes), it will redeliver the message. Pros: Guarantees that every message will be delivered. Cons: Duplicate messages are possible. The consumer application must be idempotent (processing the same message multiple times has no additional effect). This is the most common and practical semantic. Exactly-Once The “holy grail” of messaging. Guarantees that each message is delivered and processed exactly one time. This is extremely complex to achieve and requires coordination between the producer, broker, and consumer, often using transactions. For example, the producer writes to the queue and the consumer processes the message and updates its own database all within a single, distributed transaction. Pros: Strongest guarantee. Cons: Significantly lower throughput and higher latency. High implementation complexity. 7. Ensuring High Availability: Replication What happens if a broker holding the leader partition for a topic fails? To prevent data loss and unavailability, we use replication.\nEach partition is replicated across multiple brokers (e.g., a replication factor of 3). One broker is the leader for the partition (handles all reads and writes), and the others are followers. Followers pull data from the leader to keep their copy of the partition log synchronized. If the leader broker fails, a coordination service (like ZooKeeper or an internal Raft-based quorum) promotes one of the synchronized followers to be the new leader. The definition of “synchronized” is key. Systems like Kafka use an In-Sync Replica (ISR) list. A follower is in the ISR if it is not too far behind the leader. A write is only considered committed when all brokers in the ISR have acknowledged it. 8. Conclusion: A Game of Trade-offs Designing a distributed message queue is a masterclass in system design trade-offs:\nThroughput vs. Guarantees: Exactly-once semantics provide strong guarantees but come at the cost of performance. At-most-once is fast but lossy. Durability vs. Latency: Writing every message to disk synchronously is durable but slow. Asynchronous writes or relying on the page cache is faster but carries a small risk of data loss on a crash. Ordering vs. Load Balancing: Key-based partitioning provides ordering but can lead to “hot spots” if one key is very active. Round-robin provides better load balancing but sacrifices ordering. In an interview, demonstrating your grasp of these core concepts—Partitioning, Durability, Delivery Semantics, and Replication—and your ability to reason about their trade-offs is the path to a successful design.\n",
  "wordCount" : "1188",
  "inLanguage": "en",
  "datePublished": "2021-03-04T09:25:27Z",
  "dateModified": "2021-03-04T09:25:27Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://serhatgiydiren.com/system-design-interview-distributed-message-queue/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Serhat Giydiren",
    "logo": {
      "@type": "ImageObject",
      "url": "https://serhatgiydiren.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://serhatgiydiren.com/" accesskey="h" title="Serhat Giydiren (Alt + H)">Serhat Giydiren</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://serhatgiydiren.com/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://serhatgiydiren.com/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://serhatgiydiren.com/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://serhatgiydiren.com/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      System Design Interview - Distributed Message Queue
    </h1>
    <div class="post-meta"><span title='2021-03-04 09:25:27 +0000 +0000'>March 4, 2021</span>&nbsp;·&nbsp;6 min

</div>
  </header> 
  <div class="post-content"><p>For a curated list of system design interview resources, check out our <a href="/helpful-resources-for-system-design-interviews"
   
   >Helpful Resources for System Design Interviews</a>
 page.</p>
<p>For a comprehensive list of resources for tech interviews, check out our <a href="/best-resources-for-tech-interviews"
   
   >Best Resources for Tech Interviews</a>
 page.</p>
<h2 id="1-introduction-the-power-of-asynchronous-communication">1. Introduction: The Power of Asynchronous Communication<a hidden class="anchor" aria-hidden="true" href="#1-introduction-the-power-of-asynchronous-communication">#</a></h2>
<p>In modern distributed systems, services need to communicate with each other. Synchronous communication (e.g., via REST APIs) is simple but creates tight coupling; if the receiving service is slow or down, the sending service is blocked. This brittleness is a major liability at scale.</p>
<p><strong>Message Queues</strong> are a foundational technology for building robust, scalable, and decoupled systems. They enable asynchronous communication: a service (the <strong>producer</strong>) sends a message to a queue without waiting for the recipient (the <strong>consumer</strong>) to process it. The consumer can then process the message at its own pace.</p>
<p>A single-node message queue, however, has limitations:</p>
<ul>
<li><strong>Limited Throughput:</strong> A single server can only handle a finite number of messages per second.</li>
<li><strong>Single Point of Failure (SPOF):</strong> If the server fails, the entire communication backbone of the application goes down.</li>
<li><strong>Limited Storage:</strong> It can only store a limited number of messages.</li>
</ul>
<p>To overcome these, we build a <strong>Distributed Message Queue</strong>: a cluster of servers (brokers) that work together to provide a single, highly scalable and resilient messaging service. This guide explores the design of such a system in an interview context.</p>
<h2 id="2-core-requirements-and-design-goals">2. Core Requirements and Design Goals<a hidden class="anchor" aria-hidden="true" href="#2-core-requirements-and-design-goals">#</a></h2>
<p><strong>Functional Requirements:</strong></p>
<ul>
<li><code>Publish(topic, message)</code>: A producer sends a message to a specific topic.</li>
<li><code>Subscribe(topic)</code>: A consumer subscribes to a topic to receive messages.</li>
<li><code>Acknowledge(message)</code>: A consumer informs the queue that a message has been successfully processed.</li>
</ul>
<p><strong>Non-Functional Requirements:</strong></p>
<ul>
<li><strong>High Throughput:</strong> The system must handle a very large number of messages per second (millions, in some cases).</li>
<li><strong>High Scalability:</strong> Must scale horizontally by adding more brokers to handle increased load.</li>
<li><strong>High Availability &amp; Fault Tolerance:</strong> The system must remain operational and not lose messages even if some brokers fail.</li>
<li><strong>Durability:</strong> Once a message is accepted by the queue, it should not be lost.</li>
<li><strong>Tunable Delivery Semantics:</strong> The system should support different guarantees for message delivery.</li>
</ul>
<h2 id="3-high-level-architecture">3. High-Level Architecture<a hidden class="anchor" aria-hidden="true" href="#3-high-level-architecture">#</a></h2>
<p>A distributed message queue consists of a few key components:</p>
<ul>
<li><strong>Producers:</strong> Client applications that create and send messages.</li>
<li><strong>Consumers:</strong> Client applications that subscribe to topics and process messages.</li>
<li><strong>Brokers:</strong> The core servers that form the queue cluster. They are responsible for receiving messages from producers, storing them, and delivering them to consumers.</li>
<li><strong>Topics (or Queues):</strong> Named channels to which messages are published. A topic represents a specific stream of data.</li>
</ul>
<h2 id="4-core-challenge-1-partitioning-for-scalability">4. Core Challenge 1: Partitioning for Scalability<a hidden class="anchor" aria-hidden="true" href="#4-core-challenge-1-partitioning-for-scalability">#</a></h2>
<p>To achieve high throughput, a single topic must be spread across multiple brokers. This is done through <strong>partitioning</strong> (or sharding).</p>
<ul>
<li>A topic is divided into multiple <strong>partitions</strong>. Each partition is an independent, ordered sequence of messages.</li>
<li>Each partition is managed by a single broker, which acts as the <strong>leader</strong> for that partition.</li>
<li>When a producer sends a message to a topic, it must decide which partition to send it to. This can be done in several ways:
<ul>
<li><strong>Round-Robin:</strong> Distribute messages evenly across all partitions. This is good for load balancing but does not guarantee message ordering.</li>
<li><strong>Key-Based Partitioning:</strong> <code>partition_index = hash(key) % num_partitions</code>. All messages with the same key (e.g., <code>user_id</code>) will go to the same partition. This is crucial as it <strong>guarantees message ordering for a given key</strong>.</li>
</ul>
</li>
</ul>
<p>By partitioning a topic, we can process messages in parallel across many brokers and consumers, allowing the system to scale horizontally.</p>
<h2 id="5-core-challenge-2-durability-and-storage">5. Core Challenge 2: Durability and Storage<a hidden class="anchor" aria-hidden="true" href="#5-core-challenge-2-durability-and-storage">#</a></h2>
<p>How do brokers store messages to ensure they are not lost?</p>
<ul>
<li><strong>In-Memory Storage:</strong> Extremely fast but not durable. If a broker crashes, all messages it holds are lost. Unsuitable for most use cases.</li>
<li><strong>Disk-Based Storage:</strong> Messages are written to disk, providing durability. The main challenge is performance.</li>
</ul>
<p>Modern systems like Apache Kafka use a <strong>log-structured storage</strong> model. Each partition is an append-only log file on disk.</p>
<ul>
<li><strong>Writes</strong> are extremely fast sequential appends.</li>
<li><strong>Reads</strong> are also sequential (consumers read messages in order).</li>
<li>This model leverages the operating system&rsquo;s page cache for fast access while ensuring data is safely persisted on disk.</li>
</ul>
<h2 id="6-core-challenge-3-delivery-semantics">6. Core Challenge 3: Delivery Semantics<a hidden class="anchor" aria-hidden="true" href="#6-core-challenge-3-delivery-semantics">#</a></h2>
<p>This is often the most critical part of the design discussion. What guarantee does the system provide about message delivery?</p>
<h4 id="at-most-once">At-Most-Once<a hidden class="anchor" aria-hidden="true" href="#at-most-once">#</a></h4>
<ul>
<li>The producer sends a message. If there&rsquo;s a network error or broker failure, the message might be lost. The producer does not retry.</li>
<li><strong>Pros:</strong> Highest throughput, lowest latency.</li>
<li><strong>Cons:</strong> Messages can be lost. Suitable for non-critical data like metrics collection.</li>
</ul>
<h4 id="at-least-once">At-Least-Once<a hidden class="anchor" aria-hidden="true" href="#at-least-once">#</a></h4>
<ul>
<li>The producer sends a message and waits for an acknowledgment (ACK) from the broker. If no ACK is received, the producer retries.</li>
<li>The consumer fetches a message, processes it, and then sends an ACK to the broker. If the broker doesn&rsquo;t receive an ACK (e.g., the consumer crashes), it will redeliver the message.</li>
<li><strong>Pros:</strong> Guarantees that every message will be delivered.</li>
<li><strong>Cons:</strong> <strong>Duplicate messages</strong> are possible. The consumer application must be <strong>idempotent</strong> (processing the same message multiple times has no additional effect). This is the most common and practical semantic.</li>
</ul>
<h4 id="exactly-once">Exactly-Once<a hidden class="anchor" aria-hidden="true" href="#exactly-once">#</a></h4>
<ul>
<li>The &ldquo;holy grail&rdquo; of messaging. Guarantees that each message is delivered and processed exactly one time.</li>
<li>This is extremely complex to achieve and requires coordination between the producer, broker, and consumer, often using <strong>transactions</strong>.</li>
<li>For example, the producer writes to the queue and the consumer processes the message and updates its own database all within a single, distributed transaction.</li>
<li><strong>Pros:</strong> Strongest guarantee.</li>
<li><strong>Cons:</strong> Significantly lower throughput and higher latency. High implementation complexity.</li>
</ul>
<h2 id="7-ensuring-high-availability-replication">7. Ensuring High Availability: Replication<a hidden class="anchor" aria-hidden="true" href="#7-ensuring-high-availability-replication">#</a></h2>
<p>What happens if a broker holding the leader partition for a topic fails? To prevent data loss and unavailability, we use <strong>replication</strong>.</p>
<ul>
<li>Each partition is replicated across multiple brokers (e.g., a replication factor of 3).</li>
<li>One broker is the <strong>leader</strong> for the partition (handles all reads and writes), and the others are <strong>followers</strong>.</li>
<li>Followers pull data from the leader to keep their copy of the partition log synchronized.</li>
<li>If the leader broker fails, a coordination service (like ZooKeeper or an internal Raft-based quorum) promotes one of the synchronized followers to be the new leader.</li>
<li>The definition of &ldquo;synchronized&rdquo; is key. Systems like Kafka use an <strong>In-Sync Replica (ISR)</strong> list. A follower is in the ISR if it is not too far behind the leader. A write is only considered committed when all brokers in the ISR have acknowledged it.</li>
</ul>
<h2 id="8-conclusion-a-game-of-trade-offs">8. Conclusion: A Game of Trade-offs<a hidden class="anchor" aria-hidden="true" href="#8-conclusion-a-game-of-trade-offs">#</a></h2>
<p>Designing a distributed message queue is a masterclass in system design trade-offs:</p>
<ul>
<li><strong>Throughput vs. Guarantees:</strong> Exactly-once semantics provide strong guarantees but come at the cost of performance. At-most-once is fast but lossy.</li>
<li><strong>Durability vs. Latency:</strong> Writing every message to disk synchronously is durable but slow. Asynchronous writes or relying on the page cache is faster but carries a small risk of data loss on a crash.</li>
<li><strong>Ordering vs. Load Balancing:</strong> Key-based partitioning provides ordering but can lead to &ldquo;hot spots&rdquo; if one key is very active. Round-robin provides better load balancing but sacrifices ordering.</li>
</ul>
<p>In an interview, demonstrating your grasp of these core concepts—<strong>Partitioning, Durability, Delivery Semantics, and Replication</strong>—and your ability to reason about their trade-offs is the path to a successful design.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://serhatgiydiren.com/tags/system-design/">System Design</a></li>
      <li><a href="https://serhatgiydiren.com/tags/distributed-systems/">Distributed Systems</a></li>
      <li><a href="https://serhatgiydiren.com/tags/message-queue/">Message Queue</a></li>
      <li><a href="https://serhatgiydiren.com/tags/scalability/">Scalability</a></li>
      <li><a href="https://serhatgiydiren.com/tags/architecture/">Architecture</a></li>
      <li><a href="https://serhatgiydiren.com/tags/interview-prep/">Interview Prep</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://serhatgiydiren.com/">Serhat Giydiren</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
